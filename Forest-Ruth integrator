#define _USE_MATH_DEFINES
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <vector>
#include <string>
#include <string.h>
#include "nbody.hpp"
using namespace std;
int G=1;
double h = 1e-6;


Vec a(int i, nbody sim) {    
    Vec ri= sim.r(i);
    Vec ar={0,0,0};

    for (int j =0; j<sim.bodies(); ++j){
        Vec rj = sim.r(j);
        double mj= sim.m(j);
        double mi= sim.m(i);
        Vec afst= ri-rj;

        if (i!=j){
            ar-= G*mj*afst/afst.norm3();
            } 
        }
    return ar;
}

double Energy(nbody sim){
    double E=0;

    for (int i=0; i<sim.bodies();++i){
        Vec ri = sim.r(i);
        double mi=sim.m(i);
        Vec vi= sim.v(i);
        E+=mi*vi.norm2()/2;

        for(int j =0; j<sim.bodies(); ++j){
            Vec rj = sim.r(j);
            double mj= sim.m(j);
            Vec afst= ri-rj;

            if (i!=j){
                E-= 1/2*G*mi*mj/afst.norm();
            }
        }
    }
    return E;
}


int main(){
    using namespace std;
    int N=0;
     ofstream outfile("pos.txt");
    outfile << setprecision(8);
    ofstream outfile2("speed.txt");
    outfile2 << setprecision(8);
    ofstream outfile3("energy.txt");
    outfile2 << setprecision(8);
    ofstream time("time.txt");
    time << setprecision(8);
    string initial_i;
    nbody sim;
    fstream initialNfile("Initial_cond.txt");
    int l=0;
    while (getline(initialNfile, initial_i)){
        if(l>4){
        
            double m = stod(initial_i.substr(2,4));

            double rx = stod(initial_i.substr(7, 4));
            double ry = stod(initial_i.substr(12, 4));
            double rz = stod(initial_i.substr(17, 4));
            double vx = stod(initial_i.substr(22, 4));
            double vy = stod(initial_i.substr(27, 4));
            double vz = stod(initial_i.substr(32, 4));
            Vec pos{rx, ry, rz};
            Vec vel{vx,vy,vz};
            sim.add_mass(m);
            sim.add_pos(pos);
            sim.add_vel(vel);
        ++N;
        }++l;}

    initialNfile.close();
    sim.set_N(N);
    nbody n0= sim;
    nbody n1=sim;
    nbody nr =sim;
    double theta= 1.35120719195966;
    
    for (double t = 0.00; t <= 1; t+=h){

    time << t << '\n';
    outfile3 << Energy(n0) << '\n';

  
//r van deeltje wordt paar keer vernieuwd in 1 lus, dus nr is tussenklasse die voor deeltje i 
//telkens zijn nieuwe waarde gebruikt en voor de andere deeltjes hun positie zoals in n0 om de versnelling te berekenen,
// aangezien voor deeltje 2 de versnelling nog moet berekend worden met de oude positie van deeltje 1 zoals in n0
    
        
for(int i=0; i<N; i++){ 
    
    nr.swap_r(i, n0.r(i)+ h*theta*n0.v(i)*0.5);
    nr.swap_v(i, n0.v(i)+ theta*h*a(i,nr));
    
    nr.swap_r(i, nr.r(i) +h*(1-theta)*nr.v(i)*0.5);
    nr.swap_v(i, nr.v(i) +h*(1-2*theta)*a(i,nr));
    
    nr.swap_r(i,nr.r(i)+ h*(1-theta)*nr.v(i)*0.5); 
    nr.swap_v(i, nr.v(i)+ theta*h*a(i,nr));
    
    nr.swap_r(i,nr.r(i) + h*theta*nr.v(i)*0.5);

    n1.swap_r(i, nr.r(i));       //nieuwe positie van i
    n1.swap_v(i,nr.v(i));       //nieuwe snelheid van i
    nr.swap_r(i,n0.r(i));     // nr terug gelijk aan n0 om positie van volgende deeltje te berekenen
     
}

    for(int i=0; i<N; i++){
    outfile << n0.r(i).x() << ' ' << n0.r(i).y()<<' '<<  n0.r(i).z()<<' ';
    outfile2 <<n0.v(i).x() << ' ' <<n0.v(i).y()<<' '<< n0.v(i).z()<<' ';

    n0.swap_r(i,n1.r(i));
    n0.swap_v(i,n1.v(i));
    }
 
    outfile << '\n';
    outfile2 << '\n';
    

}
  
};

